---
alwaysApply: true
---

# Testing Principles and Requirements

## CRITICAL: Keep Tests Passing

**Before making ANY changes:**
1. ✅ Run tests: `./gradlew test`
2. ✅ All tests must pass before proceeding
3. ✅ Fix failing tests immediately - do not accumulate test failures
4. ✅ Never commit failing tests

**After making changes:**
1. ✅ Run tests again: `./gradlew test`
2. ✅ Fix any tests broken by your changes
3. ✅ Add tests for new functionality
4. ✅ Verify all tests pass before committing

## Testing Strategy: Hourglass Pattern

### Unit Tests (Wide Base - Maximize)
- **Maximize Coverage**: Write unit tests for all business logic, utility functions, and pure functions
- **Fast Execution**: Unit tests should run in milliseconds; aim for thousands of tests
- **Tight Scoping**: Test individual functions, classes, or small components in isolation
- **Mock External Dependencies**: Mock APIs, databases, file systems, and other external services
- **Test Coverage**: Aim for >80% code coverage through unit tests

### Integration Tests (Narrow Middle - Minimal)
- **Minimal Use**: Use sparingly for testing component interactions that can't be tested at unit or stack level
- **Specific Purpose**: Only when testing interactions between a few tightly-coupled components
- **Avoid Overuse**: Prefer unit tests or higher-level stack tests over isolated integration tests

### Higher-Level Stack Tests (Wide Top - Prefer)
- **Test Full Stack**: Prefer testing on as much of the stack as practical (UI → ViewModel → Repository → Data Source)
- **Real Components**: Use real implementations where possible (in-memory databases, test servers, etc.)
- **End-to-End Scenarios**: Test complete user flows and business scenarios
- **Real-World Behavior**: Ensure tests reflect actual runtime behavior and interactions

## Test Requirements

### When Implementing Features
- ✅ **REQUIRED: Add Tests**: Write tests alongside implementation, not after
- ✅ **REQUIRED: Test New Functionality**: Every new feature, class, and function MUST have tests
- ✅ **Test Edge Cases**: Test boundary conditions, null values, and error scenarios
- ✅ **Test Error Handling**: Test error paths and failure scenarios
- ✅ **Test Coverage**: Aim for >80% code coverage for new code

### Test Structure (AAA Pattern)
```kotlin
@Test
fun `should do something when condition is met`() {
    // Arrange - Set up test data and dependencies
    val dependency = MockDependency()
    val subject = Subject(dependency)
    
    // Act - Execute the code being tested
    val result = subject.doSomething()
    
    // Assert - Verify the expected outcome
    assertEquals(expected, result)
}
```

### Test Naming
- Use descriptive test names that explain what is being tested
- Format: `should <expected behavior> when <condition>`
- Example: `should return error when user input is invalid`

## Test Best Practices

### DO ✅
- Write tests before or alongside implementation
- Keep tests independent and isolated
- Use meaningful test names
- Test edge cases and error scenarios
- Mock external dependencies in unit tests
- Use real implementations in stack-level tests
- Run tests frequently during development
- Fix failing tests immediately
- **Test accessibility features**: Test with accessibility services enabled, different text sizes, high contrast mode
- **Test with diverse scenarios**: Test error recovery, reduced motion, one-handed use, voice commands

### DON'T ❌
- **NEVER skip tests** - All new functionality MUST have tests (not just "non-trivial" code)
- Don't leave tests in a failing state
- Don't test implementation details
- Don't create brittle tests that break on refactoring
- Don't accumulate test failures
- Don't commit failing tests
- Don't create PRs without tests for new functionality

## Refactoring with Tests

**REQUIRED before refactoring:**
1. ✅ All tests must pass
2. ✅ If tests are failing, fix them first
3. ✅ Run tests after each refactoring step
4. ✅ Keep tests green throughout refactoring
5. ✅ Tests should pass with same assertions before and after

**If tests need to change during refactoring:**
- This means behavior changed (may be intentional, but should be explicit)
- Update tests to reflect new behavior
- Document why behavior changed

## Test Examples

### Unit Test (Fast, Tight Scoping)
```kotlin
@Test
fun `should return error when input is invalid`() {
    // Arrange
    val validator = InputValidator()
    val invalidInput = ""
    
    // Act
    val result = validator.validate(invalidInput)
    
    // Assert
    assertTrue(result.isError)
    assertEquals("Input cannot be empty", result.errorMessage)
}
```

### Stack-Level Test (Full Stack, Real Components)
```kotlin
@Test
fun `should display user profile after successful login`() = runTest {
    // Arrange - Use real implementations where practical
    val testDatabase = createInMemoryDatabase()
    val repository = UserRepository(testDatabase)
    val viewModel = UserViewModel(repository)
    
    // Act - Test full stack interaction
    viewModel.login("user@example.com", "password")
    
    // Assert - Verify end-to-end behavior
    val state = viewModel.uiState.value
    assertTrue(state is UserUiState.Success)
}
```

## Accessibility Testing

### Accessibility Test Requirements

**When testing UI components, also test accessibility:**
- ✅ **Screen Reader Testing**: Test with TalkBack/VoiceOver enabled
- ✅ **Touch Target Testing**: Verify minimum 48dp × 48dp (or larger for motor disabilities)
- ✅ **Color Contrast Testing**: Verify WCAG AA compliance (4.5:1 for text)
- ✅ **Keyboard Navigation**: Test all interactive elements are keyboard accessible
- ✅ **Error Announcements**: Verify errors are announced to screen readers
- ✅ **State Changes**: Verify loading, success, error states are announced
- ✅ **Dynamic Content**: Verify live regions work for dynamic content
- ✅ **Accessibility Preferences**: Test with different accessibility settings enabled
  - Reduced motion
  - High contrast mode
  - Large text sizes
  - Different color schemes
  - Sensory preferences (animations, sounds, haptics)

### Accessibility Test Examples

```kotlin
@Test
fun `should announce error to screen reader when validation fails`() {
    // Test that error semantics are set correctly
    val semantics = composeTestRule.onNodeWithText("Email")
        .fetchSemanticsNode()
    
    assertTrue(semantics.config.contains(SemanticsActions.GetText))
    // Verify error is announced
}

@Test
fun `should respect reduced motion preference`() {
    val preferences = AccessibilityPreferences(reduceMotion = true)
    // Test that animations are disabled
    // Verify no animations occur
}

@Test
fun `should support large text sizes`() {
    // Test with text size multiplier > 1.0
    val preferences = AccessibilityPreferences(textSizeMultiplier = 1.5f)
    // Verify text scales appropriately
    // Verify layout doesn't break
}
```

### User Testing with Diverse Users

**Include users with diverse abilities in testing:**
- Visual disabilities (blind, low vision, color blind)
- Hearing disabilities (deaf, hard of hearing)
- Motor disabilities (limited dexterity, tremors)
- Cognitive disabilities (learning, memory, attention)
- Neurodivergent (autism, ADHD, dyslexia)
- Mental health conditions (anxiety, depression)
- Chronic conditions (pain, fatigue)
- Older adults (age-related changes)
- Multiple overlapping conditions
- Situational limitations (bright sunlight, one-handed use)

**See:** `docs/architecture/COMPREHENSIVE_ACCESSIBILITY_GUIDE.md` for complete testing strategy

## Related Documentation

- `AI_AGENT_GUIDELINES.md` - Complete testing guidelines
- `docs/testing/TEST_COVERAGE.md` - Test coverage details
- `docs/testing/FRAMEWORK_ARCHITECTURE_RECOMMENDATION.md` - Test framework architecture
- `docs/architecture/COMPREHENSIVE_ACCESSIBILITY_GUIDE.md` - Comprehensive accessibility guide with testing strategy
- `.cursor/rules/accessibility.mdc` - Accessibility requirements and testing checklist
