---
alwaysApply: true
---

# Code Quality Principles

## General Principles

### Code Style
- âœ… **Consistency First**: Follow existing code patterns and conventions
- âœ… **Readability**: Write self-documenting code
- âœ… **DRY**: Avoid duplication; extract common functionality
- âœ… **SOLID Principles**: Apply object-oriented design principles
- âœ… **UK English**: Use UK English spellings (analyse, colour, organise, etc.)
- âœ… **Safe Null Handling**: NEVER use force unwrap (`!!`) operator - use safe calls (`?.`) or `?.let { }`

### Before Making Changes
1. âœ… Verify NOT on `main` branch
2. âœ… **Plan before coding** - Use structured planning checklist
3. âœ… Understand existing code and architecture
4. âœ… Check dependencies and compatibility
5. âœ… Review related code for consistency
6. âœ… Consider impact on other parts of system

### Pre-Implementation Planning (Research-Backed)

**Before writing code, complete this planning checklist:**

- [ ] **Objective**: What are we trying to achieve? (Clear goal)
- [ ] **Boundaries**: What's in scope? What's out? (Scope definition)
- [ ] **Success Metrics**: How will we know it works? (Measurable outcomes)
- [ ] **Approach**: What's the recommended pattern? (Check documentation-first)
- [ ] **Dependencies**: What do we need first? (Prerequisites)
- [ ] **Risks**: What could go wrong? (Risk assessment)

**Research shows**: Structured planning reduces errors by 30-50% and debugging time by 40-60%

### When Implementing Features
- âœ… **Start Small**: Minimal viable functionality first
- âœ… **Preserve Functionality**: Existing features must continue to work
- âœ… **Add Tests**: Write tests alongside implementation
- âœ… **Add Logging**: Implement appropriate logging
- âœ… **Update Documentation**: Keep docs in sync with code
- âœ… **Consider Accessibility**: Always implement accessibility features
- âœ… **Use ViewModel Pattern**: For screens with business logic

## Code Review Checklist

### Code Quality
- [ ] Code follows project style guidelines
- [ ] No hardcoded values (use constants or configuration)
- [ ] Proper error handling implemented
- [ ] No commented-out code or debug statements
- [ ] Meaningful variable and function names
- [ ] Functions are focused and do one thing well
- [ ] No magic numbers or strings
- [ ] Proper use of design patterns where appropriate
- [ ] **No force unwrap (`!!`) operator used** - use safe calls (`?.`) or `?.let { }`

### Architecture
- [ ] Database migrations added for schema changes
- [ ] Library functionality used instead of custom implementations
- [ ] ViewModel pattern used for screens with business logic
- [ ] Authentication considered for user-scoped features
- [ ] Data scoped to current user (userId filtering)

### Testing
- [ ] Tests added for new functionality
- [ ] All tests pass
- [ ] Edge cases tested
- [ ] Error scenarios tested

## Refactoring Guidelines

### Before Refactoring
- âœ… **All Tests Passing**: REQUIRED - Fix failing tests first
- âœ… **Test Coverage**: Ensure adequate test coverage
- âœ… **Incremental Changes**: Make small, incremental changes
- âœ… **Preserve Behavior**: Maintain existing functionality
- âœ… **Document Intent**: Explain why refactoring is necessary

### During Refactoring
- âœ… Run tests after each step
- âœ… Keep tests green throughout
- âœ… Verify behavior is preserved
- âœ… Update tests if behavior changes (document why)

## Best Practices

### DO âœ…
- Follow existing code patterns
- Write self-documenting code
- Extract common functionality
- Use meaningful names
- Keep functions focused
- Add tests for new code
- Update documentation
- Consider accessibility
- Use ViewModel pattern
- Handle errors properly

### DON'T âŒ
- Don't duplicate code
- Don't use magic numbers/strings
- Don't hardcode values
- Don't leave commented code
- Don't skip tests
- Don't ignore error handling
- Don't break existing functionality
- Don't skip documentation updates
- **NEVER use force unwrap (`!!`) operator** - use safe calls (`?.`) or `?.let { }` instead

### Safe Null Handling Examples

```kotlin
// âŒ BAD: Force unwrap - can crash if null
if (quoteText != null) {
    Text(text = quoteText!!)  // DON'T DO THIS
}

// âœ… GOOD: Safe call with let
quoteText?.let { text ->
    Text(text = text)
}

// âœ… GOOD: Safe call with elvis operator
Text(text = quoteText ?: "Default value")

// âœ… GOOD: Explicit null check
if (quoteText != null) {
    Text(text = quoteText)  // Smart cast works here
}
```

## AI-Assist Boundaries (Research-Backed)

**Research shows**: Clear boundaries reduce cognitive load by 25-35% and improve collaboration effectiveness.

### AI Handles (With Human Review)

**AI can generate, but human must review:**
- âœ… **Code generation** - AI generates code, human reviews for correctness
- âœ… **Test generation** - AI generates tests, human validates coverage and edge cases
- âœ… **Documentation generation** - AI generates docs, human ensures accuracy and completeness
- âœ… **Boilerplate code** - AI generates repetitive code, human ensures consistency
- âœ… **Refactoring suggestions** - AI suggests improvements, human evaluates impact
- âœ… **Code formatting** - AI applies formatting, human verifies style compliance
- âœ… **Error handling patterns** - AI suggests patterns, human validates appropriateness

### Human Required (AI Assists Only)

**These require human decision-making and review:**
- ðŸ”’ **Architecture decisions** - System design, component structure, technology choices
- ðŸ”’ **Security reviews** - Authentication, authorization, data protection, vulnerability assessment
- ðŸ”’ **Business logic validation** - Domain rules, user requirements, edge case handling
- ðŸ”’ **Performance-critical code** - Optimization, resource management, scalability concerns
- ðŸ”’ **User-facing changes** - UI/UX decisions, accessibility, user experience
- ðŸ”’ **Data model design** - Database schema, data relationships, migration strategy
- ðŸ”’ **API design** - Endpoints, contracts, versioning, backward compatibility
- ðŸ”’ **Integration decisions** - Third-party services, external dependencies, compatibility

### Collaboration Pattern

**Recommended workflow:**
1. **AI generates** code/suggestions based on requirements
2. **Human reviews** for correctness, security, and appropriateness
3. **Human decides** on architecture, business logic, and user-facing changes
4. **AI assists** with implementation details, formatting, and documentation
5. **Both iterate** based on feedback and testing

### Benefits

- âœ… **Reduced cognitive load** - Clear responsibilities reduce decision fatigue
- âœ… **Faster development** - AI handles repetitive tasks, human focuses on critical decisions
- âœ… **Better quality** - Human oversight ensures correctness and appropriateness
- âœ… **Improved learning** - Clear boundaries help understand AI capabilities and limitations

**Research shows**: This pattern increases productivity by 15-25% while maintaining code quality.

## Related Documentation

- `AI_AGENT_GUIDELINES.md` - Complete code quality guidelines
- `docs/architecture/` - Architecture documentation
- `docs/development/` - Development guidelines
- `docs/development/lessons/RESEARCH_BASED_IMPROVEMENTS.md` - Research-backed improvements
