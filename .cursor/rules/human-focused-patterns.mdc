# Human-Focused Pattern Principles

## CRITICAL: Event-Driven Over Fixed Delays

**When implementing waits or delays:**

1. ‚úÖ **ALWAYS use event-driven waits** (wait for state changes, conditions)
2. ‚ùå **NEVER use fixed delays** unless explicitly marked as LAST RESORT
3. ‚úÖ **Use StateManager.waitForState()** for waiting on conditions
4. ‚úÖ **Use continuous monitoring loops** for feedback

### Examples

**‚ùå BAD: Fixed Delay**
```kotlin
delay(2000) // Arbitrary wait
Thread.sleep(1000)
```

**‚úÖ GOOD: Event-Driven Wait**
```kotlin
stateManager.waitForState(
    predicate = { state -> state.screenName == "Mood Management" },
    timeoutMs = 5000
)
```

**‚ö†Ô∏è LAST RESORT: Fixed Delay (only when event detection fails)**
```kotlin
// LAST RESORT: Event detection failed, need to stabilize
delay(300) // Brief stabilization delay
```

## Visual Perception First

**When detecting state or conditions:**

1. ‚úÖ **ALWAYS check visual state first** (`StateManager.getCurrentState()`)
2. ‚ùå **NEVER use system APIs first** (driver.isKeyboardShown(), etc.)
3. ‚úÖ **Use ScreenEvaluator for visual analysis**
4. ‚úÖ **Check what we "see" before checking system properties**

### Examples

**‚ùå BAD: System API First**
```kotlin
if (driver.isKeyboardShown()) { ... }
```

**‚úÖ GOOD: Visual Detection First**
```kotlin
val state = stateManager.getCurrentState()
if (state?.hasKeyboard == true) { ... }
```

## Continuous Observation Loop

**When monitoring feedback:**

1. ‚úÖ **Use continuous monitoring** (`ContinuousInteractionLoop`, `ScreenMonitor`)
2. ‚úÖ **Observe state changes continuously**
3. ‚úÖ **Process feedback as it arrives**
4. ‚ùå **Don't check once and assume**

### Examples

**‚ùå BAD: Single Check**
```kotlin
val state = getState()
if (state.isLoading) { wait() }
```

**‚úÖ GOOD: Continuous Monitoring**
```kotlin
startContinuousMonitoring()
while (!conditionMet()) {
    observeState()
    delay(100) // Small polling interval
}
```

## Feedback-Driven Adaptation

**When retrying or adapting:**

1. ‚úÖ **Observe feedback before retrying**
2. ‚úÖ **Adapt strategy based on what you see**
3. ‚ùå **Don't retry blindly**
4. ‚úÖ **Use visual feedback to guide adaptation**

### Examples

**‚ùå BAD: Blind Retry**
```kotlin
for (i in 1..3) {
    try { action() } catch { retry() }
}
```

**‚úÖ GOOD: Adaptive Retry**
```kotlin
val result = tryAction(action)
if (result is Failure) {
    observeState() // What went wrong?
    adaptStrategy(result) // Try different approach
}
```

## Human-Like Decision Making

**When making decisions:**

1. ‚úÖ **Consider context and history**
2. ‚úÖ **Use StuckDetector for repeated failures**
3. ‚úÖ **Make decisions based on current state + recent history**
4. ‚úÖ **Log from human perspective**

### Examples

**‚ùå BAD: Binary Logic**
```kotlin
if (error) { retry() } else { continue() }
```

**‚úÖ GOOD: Contextual Decision**
```kotlin
if (isStuck(recentActions)) {
    logger.info("üí≠ I've tried this ${attempts} times, it's not working")
    tryAlternativeApproach()
} else if (isBlocked(currentState)) {
    logger.info("üí° Something is blocking me, let me work around it")
    clearBlockage()
}
```

## Visual-First Error Recovery

**When recovering from errors:**

1. ‚úÖ **Try visual recovery first** (detect problem visually, solve visually)
2. ‚úÖ **Use adaptive strategies** (try alternative visual approaches)
3. ‚ö†Ô∏è **LAST RESORT: System-level fallback** (explicitly marked)

### Examples

**‚ùå BAD: System API First**
```kotlin
try {
    action()
} catch (e: Exception) {
    driver.hideKeyboard() // System-level fallback
}
```

**‚úÖ GOOD: Visual-First Recovery**
```kotlin
if (state.hasKeyboard) {
    dismissKeyboardVisually() // Visual detection and action
} else {
    // LAST RESORT: System-level fallback
    driver.hideKeyboard()
}
```

## Related Documentation

- `docs/testing/HUMAN_FOCUSED_PATTERNS.md` - Complete pattern guide
- `docs/testing/VISUAL_FIRST_COMPLIANCE_REVIEW.md` - Visual-first compliance
- `.cursor/rules/visual-first-principle.mdc` - Visual-first principle
