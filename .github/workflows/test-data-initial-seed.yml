name: Seed Test Data (Initial Setup)

on:
  workflow_dispatch:  # Manual trigger from any branch
    inputs:
      project_ref:
        description: 'Supabase Project Reference ID (leave empty to use SUPABASE_PROJECT_REF_STAGING)'
        required: false
        type: string
      environment:
        description: 'Environment to seed (staging or production)'
        required: false
        type: choice
        options:
          - staging
          - production
        default: 'staging'

jobs:
  seed-test-data:
    name: Seed Test Data
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.environment || 'staging' }}  # Use input or default to staging
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest
      
      - name: Verify token is set
        run: |
          if [ -z "${{ secrets.SUPABASE_ACCESS_TOKEN }}" ]; then
            echo "ERROR: SUPABASE_ACCESS_TOKEN secret is not set or is empty"
            exit 1
          fi
          echo "Token is set (length: $(echo -n '${{ secrets.SUPABASE_ACCESS_TOKEN }}' | wc -c))"
      
      - name: Login to Supabase
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
        run: |
          if [ -z "$SUPABASE_ACCESS_TOKEN" ]; then
            echo "ERROR: SUPABASE_ACCESS_TOKEN environment variable is empty"
            exit 1
          fi
          echo "Logging in to Supabase..."
          supabase login --token "$SUPABASE_ACCESS_TOKEN"
      
      - name: Link to Supabase project
        env:
          ENVIRONMENT: ${{ github.event.inputs.environment || 'staging' }}
          SUPABASE_DB_PASSWORD: ${{ github.event.inputs.environment == 'production' && secrets.SUPABASE_DB_PASSWORD || secrets.SUPABASE_DB_PASSWORD_STAGING || secrets.SUPABASE_DB_PASSWORD }}
        run: |
          # Determine project ref based on environment
          if [ "$ENVIRONMENT" = "production" ]; then
            PROJECT_REF="${{ secrets.SUPABASE_PROJECT_REF || github.event.inputs.project_ref }}"
            if [ -z "$PROJECT_REF" ]; then
              echo "ERROR: SUPABASE_PROJECT_REF secret is not set, or provide via workflow_dispatch project_ref input"
              exit 1
            fi
          else
            PROJECT_REF="${{ secrets.SUPABASE_PROJECT_REF_STAGING || secrets.SUPABASE_PROJECT_REF || github.event.inputs.project_ref }}"
            if [ -z "$PROJECT_REF" ]; then
              echo "ERROR: SUPABASE_PROJECT_REF_STAGING or SUPABASE_PROJECT_REF secret is not set, or provide via workflow_dispatch project_ref input"
              exit 1
            fi
          fi
          
          # Check if already linked to the correct project (skip if already linked)
          if supabase status >/dev/null 2>&1; then
            CURRENT_REF=$(supabase status 2>/dev/null | grep "Project ID" | awk '{print $3}' || echo "")
            if [ "$CURRENT_REF" = "$PROJECT_REF" ]; then
              echo "✓ Already linked to correct project: $PROJECT_REF"
              exit 0
            else
              echo "⚠ Currently linked to different project: $CURRENT_REF"
              echo "   Will re-link to: $PROJECT_REF"
            fi
          fi
          
          echo "Linking to $ENVIRONMENT project: $PROJECT_REF"
          if [ -z "$SUPABASE_DB_PASSWORD" ]; then
            echo "Warning: SUPABASE_DB_PASSWORD_STAGING or SUPABASE_DB_PASSWORD not set. CLI will attempt to use PAT for database connection."
          else
            echo "Using database password for linking"
          fi
          
          # Retry linking with exponential backoff to handle network timeouts
          # This addresses intermittent network issues, but if it consistently fails,
          # it may indicate a real problem (IP ban, resource limits, network restrictions)
          MAX_RETRIES=3
          RETRY_DELAY=10
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i of $MAX_RETRIES to link project..."
            # Use timeout to prevent hanging (30s timeout)
            if timeout 30 supabase link --project-ref "$PROJECT_REF" 2>&1; then
              echo "✓ Successfully linked to project"
              exit 0
            else
              LINK_EXIT_CODE=$?
              if [ $i -lt $MAX_RETRIES ]; then
                echo "⚠ Link attempt $i failed (exit code: $LINK_EXIT_CODE)"
                echo "   Retrying in ${RETRY_DELAY}s (exponential backoff)..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))  # Exponential backoff: 10s, 20s, 40s
              else
                echo "✗ Failed to link after $MAX_RETRIES attempts"
                echo ""
                echo "This may indicate a real issue. Check:"
                echo "  1. Supabase Dashboard → Database → Settings → Network Bans"
                echo "     (GitHub Actions IPs may be banned)"
                echo "  2. Database resource limits (CPU/RAM usage)"
                echo "  3. Network restrictions on Supabase project"
                echo "  4. Connection pooler availability"
                echo ""
                echo "If this persists, it's likely not a transient network issue."
                exit 1
              fi
            fi
          done
      
      - name: Get Supabase URL
        id: supabase-url
        env:
          ENVIRONMENT: ${{ github.event.inputs.environment || 'staging' }}
        run: |
          # Get Supabase URL from linked project or construct from project ID
          SUPABASE_URL=$(supabase status 2>/dev/null | grep "API URL" | awk '{print $3}' || echo "")
          if [ -z "$SUPABASE_URL" ]; then
            # Fallback: construct from project ID
            if [ "$ENVIRONMENT" = "production" ]; then
              PROJECT_REF="${{ secrets.SUPABASE_PROJECT_REF || github.event.inputs.project_ref }}"
            else
              PROJECT_REF="${{ secrets.SUPABASE_PROJECT_REF_STAGING || secrets.SUPABASE_PROJECT_REF || github.event.inputs.project_ref }}"
            fi
            SUPABASE_URL="https://${PROJECT_REF}.supabase.co"
          fi
          echo "supabase_url=$SUPABASE_URL" >> $GITHUB_OUTPUT
          echo "Using Supabase URL: $SUPABASE_URL"
      
      - name: Cache apt packages
        uses: actions/cache@v4
        id: cache-apt
        with:
          path: /var/cache/apt
          key: apt-${{ runner.os }}-${{ hashFiles('.github/workflows/test-data-initial-seed.yml') }}
          restore-keys: |
            apt-${{ runner.os }}-
      
      - name: Install required tools
        run: |
          sudo apt-get update
          sudo apt-get install -y jq bc uuid-runtime || true
      
      - name: Create test users
        env:
          ENVIRONMENT: ${{ github.event.inputs.environment || 'staging' }}
          SUPABASE_URL: ${{ steps.supabase-url.outputs.supabase_url }}
          SUPABASE_SECRET_KEY: ${{ github.event.inputs.environment == 'production' && secrets.SUPABASE_SECRET_KEY || secrets.SUPABASE_SECRET_KEY_STAGING || secrets.SUPABASE_SECRET_KEY }}
        run: |
          echo "Creating test users in Supabase Auth ($ENVIRONMENT)..."
          bash supabase/scripts/create-test-users.sh
      
      - name: Ensure generate_mood_score function exists
        run: |
          echo "Ensuring generate_mood_score function exists..."
          # Use HTTP-based approach: create temporary migration and push via supabase db push
          # This matches the working pattern of user setup (HTTP API via Management API)
          # Migration name must match pattern: YYYYMMDDHHMMSS_name.sql
          MIGRATION_NAME="$(date +%Y%m%d%H%M%S)_generate_mood_score"
          mkdir -p supabase/migrations
          cp supabase/seed/functions/generate_mood_score.sql "supabase/migrations/${MIGRATION_NAME}.sql"
          if supabase db push; then
            echo "✓ Function created successfully"
            # Clean up temp migration file after successful push
            rm -f "supabase/migrations/${MIGRATION_NAME}.sql"
          else
            echo "Warning: Failed to create function (may already exist)"
            # Clean up temp migration file on failure
            rm -f "supabase/migrations/${MIGRATION_NAME}.sql"
          fi
      
      - name: Load baseline mood data
        run: |
          echo "Loading baseline mood data (30 days)..."
          # Use HTTP-based approach: create temporary migration and push via supabase db push
          # This matches the working pattern of user setup (HTTP API via Management API)
          # Migration name must match pattern: YYYYMMDDHHMMSS_name.sql
          MIGRATION_NAME="$(date +%Y%m%d%H%M%S)_load_baseline_mood_data"
          mkdir -p supabase/migrations
          cp supabase/seed/002_load_baseline_mood_data.sql "supabase/migrations/${MIGRATION_NAME}.sql"
          if supabase db push; then
            echo "✓ Baseline mood data loaded successfully"
            # Clean up temp migration file after successful push
            rm -f "supabase/migrations/${MIGRATION_NAME}.sql"
          else
            echo "Warning: Some data may already exist (this is expected if re-running)"
            # Clean up temp migration file on failure
            rm -f "supabase/migrations/${MIGRATION_NAME}.sql"
          fi
      
      - name: Verify data was seeded
        env:
          SUPABASE_DB_PASSWORD: ${{ secrets.SUPABASE_DB_PASSWORD_STAGING || secrets.SUPABASE_DB_PASSWORD }}
        run: |
          echo "Verifying test data was seeded..."
          # Query to check test users and their mood entries
          echo "Running verification query..."
          supabase db execute "
            SELECT 
              u.email,
              COUNT(m.id) as entry_count,
              MIN(DATE(to_timestamp(m.timestamp / 1000))) as earliest_date,
              MAX(DATE(to_timestamp(m.timestamp / 1000))) as latest_date
            FROM auth.users u
            LEFT JOIN public.moods m ON m.user_id = u.id
            WHERE u.email LIKE 'test-%@electric-sheep.test'
            GROUP BY u.email
            ORDER BY u.email;
          " || {
            echo "Warning: Could not verify data (this is non-critical)"
            exit 0
          }
      
      - name: Summary
        if: always()
        run: |
          echo "## Test Data Seeding Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Time**: $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger**: Manual (workflow_dispatch)" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ github.event.inputs.environment || 'staging' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Test Users Created:" >> $GITHUB_STEP_SUMMARY
          echo "- 8 test users (2 tech levels × 4 mood patterns)" >> $GITHUB_STEP_SUMMARY
          echo "- Email pattern: `test-{tech-level}-{mood-pattern}@electric-sheep.test`" >> $GITHUB_STEP_SUMMARY
          echo "- Password: `test-password-123` (default)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Data Loaded:" >> $GITHUB_STEP_SUMMARY
          echo "- 30 days of baseline mood data per user" >> $GITHUB_STEP_SUMMARY
          echo "- Data up until yesterday (avoids partial day data)" >> $GITHUB_STEP_SUMMARY

