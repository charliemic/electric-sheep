#!/usr/bin/env python3
"""
Video annotation pipeline for test automation videos.

This script adds frame-accurate annotations to test videos based on action logs
generated by the test automation framework.

Usage:
    python scripts/annotate-video.py <video_path> <action_log_path> <output_path>

Example:
    python scripts/annotate-video.py \
        /tmp/test_results/video.mp4 \
        /tmp/test_results/action_log.json \
        /tmp/test_results/video_annotated.mp4
"""

import json
import sys
import os
from pathlib import Path

try:
    from moviepy.editor import VideoFileClip, TextClip, CompositeVideoClip
    from moviepy.video.fx.all import resize
except ImportError as e:
    print(f"‚ùå Error: Missing required dependency: {e}")
    print("   Install dependencies: pip install -r requirements.txt")
    sys.exit(1)


def create_click_marker(x, y, video_w, video_h, duration=0.5):
    """
    Create a visual click marker (ripple effect) at the specified coordinates.
    
    Args:
        x: X coordinate (device coordinates)
        y: Y coordinate (device coordinates)
        video_w: Video width in pixels
        video_h: Video height in pixels
        duration: Duration of marker animation in seconds
    
    Returns:
        CompositeVideoClip with ripple effect
    """
    # Scale coordinates (assuming video is device resolution)
    # Adjust these scale factors based on your device resolution
    # Default assumes 1080x1920 device, but video might be different
    scale_x = video_w / 1080 if video_w > 0 else 1.0
    scale_y = video_h / 1920 if video_h > 0 else 1.0
    
    marker_x = int(x * scale_x)
    marker_y = int(y * scale_y)
    
    # Create ripple circles (simplified - MoviePy doesn't have Circle, so we'll use text)
    # For a proper implementation, we'd need to create image-based markers
    # For now, we'll create a simple text-based marker
    from moviepy.editor import ImageClip
    import numpy as np
    
    # Create a simple marker using a small image
    # This is a simplified version - for better visuals, use pre-rendered marker images
    marker_text = TextClip(
        "‚óè",
        fontsize=40,
        color='yellow',
        bg_color='transparent'
    ).set_position((marker_x - 20, marker_y - 20)).set_duration(duration)
    
    return marker_text


def create_text_overlay(text, position='bottom', duration=2.0, fontsize=42):
    """
    Create a text overlay with consistent styling.
    
    Args:
        text: Text to display
        position: Position on screen ('bottom', 'top', 'center')
        duration: Duration in seconds
        fontsize: Font size in pixels
    
    Returns:
        TextClip configured with styling
    """
    # Calculate position
    if position == 'bottom':
        pos = ('center', 'bottom')
        y_offset = 60
    elif position == 'top':
        pos = ('center', 'top')
        y_offset = 60
    else:
        pos = ('center', 'center')
        y_offset = 0
    
    txt_clip = TextClip(
        text,
        fontsize=fontsize,
        color='white',
        bg_color='black@0.9',
        size=(None, None),  # Auto-size based on text
        method='caption',
        align='center',
        font='Arial-Bold'  # Use system font, fallback to default if not available
    )
    
    # Position the text
    if position == 'bottom':
        txt_clip = txt_clip.set_position(('center', video.h - txt_clip.h - y_offset))
    elif position == 'top':
        txt_clip = txt_clip.set_position(('center', y_offset))
    else:
        txt_clip = txt_clip.set_position('center')
    
    return txt_clip.set_duration(duration)


def annotate_video(video_path, action_log_path, output_path):
    """
    Annotate video with action log.
    
    Args:
        video_path: Path to input video file
        action_log_path: Path to JSON action log file
        output_path: Path to output annotated video file
    """
    # Validate inputs
    if not os.path.exists(video_path):
        print(f"‚ùå Error: Video file not found: {video_path}")
        sys.exit(1)
    
    if not os.path.exists(action_log_path):
        print(f"‚ùå Error: Action log file not found: {action_log_path}")
        sys.exit(1)
    
    print(f"üìπ Loading video: {video_path}")
    try:
        video = VideoFileClip(video_path)
        fps = video.fps
        print(f"   Video FPS: {fps}, Duration: {video.duration:.2f}s, Size: {video.w}x{video.h}")
    except Exception as e:
        print(f"‚ùå Error loading video: {e}")
        sys.exit(1)
    
    print(f"üìã Loading action log: {action_log_path}")
    try:
        with open(action_log_path, 'r') as f:
            actions = json.load(f)
        print(f"   Found {len(actions)} actions")
    except json.JSONDecodeError as e:
        print(f"‚ùå Error parsing action log JSON: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"‚ùå Error reading action log: {e}")
        sys.exit(1)
    
    if not actions:
        print("‚ö†Ô∏è  Warning: No actions found in log. Creating video without annotations.")
        video.write_videofile(
            output_path,
            fps=fps,
            codec='libx264',
            preset='medium',
            audio_codec='aac'
        )
        return
    
    # Build annotation clips
    clips = [video]
    
    for i, action in enumerate(actions):
        timestamp_sec = action.get('timestampMs', 0) / 1000.0
        
        # Validate timestamp
        if timestamp_sec < 0 or timestamp_sec > video.duration:
            print(f"‚ö†Ô∏è  Warning: Action {i+1} timestamp {timestamp_sec:.2f}s is outside video duration. Skipping.")
            continue
        
        description = action.get('description', 'Unknown action')
        print(f"   Action {i+1}/{len(actions)}: {description} at {timestamp_sec:.2f}s")
        
        # Create text overlay
        txt_clip = create_text_overlay(
            text=description,
            position='bottom',
            duration=2.0,
            fontsize=42
        ).set_start(timestamp_sec)
        
        clips.append(txt_clip)
        
        # Add visual indicator for click/swipe actions
        if action.get('coordinates'):
            coords = action['coordinates']
            if isinstance(coords, list) and len(coords) >= 2:
                x, y = coords[0], coords[1]
                try:
                    marker = create_click_marker(x, y, video.w, video.h)
                    marker = marker.set_start(timestamp_sec).set_duration(0.5)
                    clips.append(marker)
                except Exception as e:
                    print(f"‚ö†Ô∏è  Warning: Could not create click marker: {e}")
    
    # Composite all clips
    print("üé¨ Compositing video with annotations...")
    try:
        final = CompositeVideoClip(clips)
    except Exception as e:
        print(f"‚ùå Error compositing video: {e}")
        sys.exit(1)
    
    # Write output
    print(f"üíæ Writing annotated video to: {output_path}")
    try:
        final.write_videofile(
            output_path,
            fps=fps,
            codec='libx264',
            preset='medium',
            audio_codec='aac',
            bitrate='4000k'  # Higher bitrate for better quality
        )
        print("‚úÖ Video annotation complete!")
    except Exception as e:
        print(f"‚ùå Error writing video: {e}")
        sys.exit(1)
    finally:
        # Clean up
        video.close()
        if 'final' in locals():
            final.close()


def main():
    """Main entry point."""
    if len(sys.argv) != 4:
        print("Usage: python scripts/annotate-video.py <video_path> <action_log_path> <output_path>")
        print("")
        print("Example:")
        print("  python scripts/annotate-video.py \\")
        print("    /tmp/test_results/video.mp4 \\")
        print("    /tmp/test_results/action_log.json \\")
        print("    /tmp/test_results/video_annotated.mp4")
        sys.exit(1)
    
    video_path = sys.argv[1]
    action_log_path = sys.argv[2]
    output_path = sys.argv[3]
    
    # Create output directory if it doesn't exist
    output_dir = os.path.dirname(output_path)
    if output_dir and not os.path.exists(output_dir):
        os.makedirs(output_dir, exist_ok=True)
    
    annotate_video(video_path, action_log_path, output_path)


if __name__ == '__main__':
    main()

