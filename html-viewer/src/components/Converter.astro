---
// Converter component - client-side conversion
---

<div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6">
  <div class="mb-6">
    <label for="input-type" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
      Input Type
    </label>
    <select
      id="input-type"
      class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
    >
      <option value="markdown">Markdown</option>
      <option value="log">Log File</option>
      <option value="text">Plain Text</option>
    </select>
  </div>

  <div class="mb-6">
    <label for="content-input" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
      Content
    </label>
    <textarea
      id="content-input"
      rows="15"
      class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-white font-mono text-sm"
      placeholder="Paste your markdown, log, or text content here..."
    ></textarea>
  </div>

  <div class="mb-6 grid grid-cols-1 md:grid-cols-2 gap-4">
    <div>
      <label for="title-input" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
        Document Title
      </label>
      <input
        type="text"
        id="title-input"
        value="Document"
        class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
      />
    </div>
    <div>
      <label for="theme-select" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
        Theme
      </label>
      <select
        id="theme-select"
        class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
      >
        <option value="light">Light</option>
        <option value="dark">Dark</option>
        <option value="auto">Auto (System)</option>
      </select>
    </div>
  </div>

  <div class="mb-6 flex gap-4">
    <label class="flex items-center">
      <input
        type="checkbox"
        id="include-toc"
        checked
        class="mr-2"
      />
      <span class="text-sm text-gray-700 dark:text-gray-300">Include Table of Contents</span>
    </label>
    <label class="flex items-center">
      <input
        type="checkbox"
        id="embed-images"
        checked
        class="mr-2"
      />
      <span class="text-sm text-gray-700 dark:text-gray-300">Embed Images (Base64)</span>
    </label>
  </div>

  <div class="flex gap-4">
    <button
      id="convert-btn"
      class="px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-md font-medium transition-colors"
    >
      Convert to HTML
    </button>
    <button
      id="download-btn"
      class="px-6 py-2 bg-green-600 hover:bg-green-700 text-white rounded-md font-medium transition-colors"
      disabled
    >
      Download HTML
    </button>
  </div>

  <div id="preview-container" class="mt-6 hidden">
    <h3 class="text-lg font-semibold text-gray-900 dark:text-white mb-2">Preview</h3>
    <div
      id="preview"
      class="border border-gray-300 dark:border-gray-600 rounded-md p-4 bg-gray-50 dark:bg-gray-900 max-h-96 overflow-auto"
    ></div>
  </div>
</div>

<script>
  // Simple markdown converter (client-side)
  async function convertMarkdown(md: string, options: any): Promise<string> {
    // Load marked from CDN
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/marked@11.0.0/marked.min.js';
    document.head.appendChild(script);
    
    return new Promise((resolve) => {
      script.onload = () => {
        // @ts-ignore - marked is loaded from CDN
        const marked = (window as any).marked;
        marked.setOptions({ gfm: true, breaks: true, headerIds: true });
        
        const htmlContent = marked.parse(md);
        const toc = options.includeTOC ? generateTOC(htmlContent) : '';
        
        const html = buildHTMLDocument(htmlContent, {
          title: options.title,
          theme: options.theme,
          toc,
        });
        
        resolve(html);
      };
    });
  }

  function formatLog(log: string): string {
    if (log.trim().startsWith('{') || log.trim().startsWith('[')) {
      try {
        const parsed = JSON.parse(log);
        return `<pre><code class="language-json">${escapeHtml(JSON.stringify(parsed, null, 2))}</code></pre>`;
      } catch {}
    }
    const lines = log.split('\n');
    const numbered = lines.map((line, i) => `<span class="line-number">${i + 1}</span> ${escapeHtml(line)}`).join('\n');
    return `<pre><code class="language-text">${numbered}</code></pre>`;
  }

  function generateTOC(html: string): string {
    const headingRegex = /<h([2-3]) id="([^"]+)">([^<]+)<\/h[2-3]>/g;
    const headings: Array<{ level: number; id: string; text: string }> = [];
    let match;
    while ((match = headingRegex.exec(html)) !== null) {
      headings.push({ level: parseInt(match[1]), id: match[2], text: match[3] });
    }
    if (headings.length === 0) return '';
    
    let toc = '<nav class="toc"><h2>Table of Contents</h2><ul>';
    for (const heading of headings) {
      const indent = heading.level === 3 ? '  ' : '';
      toc += `${indent}<li><a href="#${heading.id}">${heading.text}</a></li>`;
    }
    toc += '</ul></nav>';
    return toc;
  }

  function buildHTMLDocument(content: string, options: any): string {
    return `<!DOCTYPE html>
<html lang="en" class="${options.theme === 'dark' ? 'dark' : ''}">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapeHtml(options.title)}</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.css" rel="stylesheet" />
  <style>
    body { max-width: 900px; margin: 0 auto; padding: 2rem; line-height: 1.7; font-size: 16px; }
    .toc { background: #f3f4f6; padding: 1.5rem; border-radius: 0.5rem; margin-bottom: 2rem; }
    .dark .toc { background: #1f2937; }
    .toc ul { list-style: none; padding-left: 0; }
    .toc li { margin: 0.5rem 0; }
    .toc a { color: #3b82f6; text-decoration: none; }
    .toc a:hover { text-decoration: underline; }
    pre { background: #1f2937; padding: 1rem; border-radius: 0.5rem; overflow-x: auto; }
    code { background: #f3f4f6; padding: 0.2rem 0.4rem; border-radius: 0.25rem; font-size: 0.9em; }
    pre code { background: transparent; padding: 0; }
    img { max-width: 100%; height: auto; border-radius: 0.5rem; margin: 1rem 0; }
    table { width: 100%; border-collapse: collapse; margin: 1rem 0; }
    th, td { border: 1px solid #e5e7eb; padding: 0.5rem; }
    th { background: #f9fafb; font-weight: 600; }
    @media (prefers-color-scheme: dark) {
      body { background: #111827; color: #f9fafb; }
      code { background: #374151; }
      th, td { border-color: #374151; }
      th { background: #1f2937; }
    }
  </style>
</head>
<body>
  <h1>${escapeHtml(options.title)}</h1>
  ${options.toc}
  ${content}
</body>
</html>`;
  }

  function escapeHtml(text: string): string {
    const map: Record<string, string> = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
    return text.replace(/[&<>"']/g, (m) => map[m]);
  }

  const inputType = document.getElementById('input-type') as HTMLSelectElement;
  const contentInput = document.getElementById('content-input') as HTMLTextAreaElement;
  const titleInput = document.getElementById('title-input') as HTMLInputElement;
  const themeSelect = document.getElementById('theme-select') as HTMLSelectElement;
  const includeToc = document.getElementById('include-toc') as HTMLInputElement;
  const embedImages = document.getElementById('embed-images') as HTMLInputElement;
  const convertBtn = document.getElementById('convert-btn') as HTMLButtonElement;
  const downloadBtn = document.getElementById('download-btn') as HTMLButtonElement;
  const previewContainer = document.getElementById('preview-container') as HTMLDivElement;
  const preview = document.getElementById('preview') as HTMLDivElement;

  let generatedHTML = '';

  convertBtn.addEventListener('click', async () => {
    const content = contentInput.value.trim();
    if (!content) {
      alert('Please enter some content');
      return;
    }

    const type = inputType.value;
    const title = titleInput.value || 'Document';
    const theme = themeSelect.value as 'light' | 'dark' | 'auto';
    const includeTOCValue = includeToc.checked;
    const embedImagesValue = embedImages.checked;

    try {
      // Use marked library (loaded via CDN in the generated HTML)
      if (type === 'markdown') {
        // We'll use marked via CDN in the generated HTML
        // For now, create a simple markdown-to-HTML converter
        generatedHTML = await convertMarkdown(content, {
          title,
          theme,
          includeTOC: includeTOCValue,
          embedImages: embedImagesValue,
        });
      } else if (type === 'log') {
        const formatted = formatLog(content);
        const escapedTitle = escapeHtml(title);
        generatedHTML = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapedTitle}</title>
  <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.css" rel="stylesheet" />
  <style>
    body { max-width: 1200px; margin: 0 auto; padding: 2rem; }
    pre { background: #1f2937; padding: 1rem; border-radius: 0.5rem; overflow-x: auto; }
    .line-number { color: #6b7280; margin-right: 1rem; }
  </style>
</head>
<body>
  <h1>${escapedTitle}</h1>
  ${formatted}
</body>
</html>`;
      } else {
        // Plain text
        const escapedTitle = escapeHtml(title);
        const escapedContent = escapeHtml(content);
        generatedHTML = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapedTitle}</title>
  <style>
    body { max-width: 900px; margin: 0 auto; padding: 2rem; line-height: 1.7; }
    pre { white-space: pre-wrap; font-family: monospace; }
  </style>
</head>
<body>
  <h1>${escapedTitle}</h1>
  <pre>${escapedContent}</pre>
</body>
</html>`;
      }

      // Show preview
      const iframe = document.createElement('iframe');
      iframe.srcdoc = generatedHTML;
      iframe.style.width = '100%';
      iframe.style.height = '400px';
      iframe.style.border = 'none';
      preview.innerHTML = '';
      preview.appendChild(iframe);

      previewContainer.classList.remove('hidden');
      downloadBtn.disabled = false;
    } catch (error) {
      console.error('Conversion error:', error);
      alert('Error converting content. Check console for details.');
    }
  });

  downloadBtn.addEventListener('click', () => {
    if (!generatedHTML) {
      alert('Please convert content first');
      return;
    }

    const blob = new Blob([generatedHTML], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${titleInput.value || 'document'}.html`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  });
</script>

